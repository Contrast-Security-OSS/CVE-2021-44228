######################################################################
# Copyright [2021] Contrast Security, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# DESCRIPTION:
#
# A script to aid in the identification of affected Java applications
# in TeamServer impacted by CVE-2021-44228 (log4j RCE vulnerability)
#
# This script collects a list of apps which have references to libs with
# a specified prefix in their name while going iterating through the users
# and gathering applications they are authorized to access.
#
# The output is a file written out to $CWD/vulnerableApps.csv and contains
# tuples of:
# {(parent) app name, lib name, lib version, use count, and user id list}
#
# PREREQUISITE:
#
# Requires a TeamServer user with view access to all applications and
# a valid API key and AUTH token
#
# USAGE:
#
# The script requires the following environment variables to be set:
#
#     CONTRAST__AUTHORIZATION
#     CONTRAST__API_KEY
#     CONTRAST__ORG
#     CONTRAST__URL             :example -  https://app.contrastsecurity.com/
#
# @author: ching-chiang.van@contrastsecurity.com
#
#####################################################################

# -*- coding: utf-8 -*-
import requests
import json
import io
import os
import re
import sys

CONTRAST_AUTHORIZATION=os.getenv('CONTRAST__AUTHORIZATION', '<<authorization>>')
CONTRAST_API_KEY=os.getenv('CONTRAST__API_KEY', '<<api_key>>')
CONTRAST_ORG=os.getenv('CONTRAST__ORG', '<<orgId>>')
CONTRAST_URL=os.getenv('CONTRAST__URL', "https://app.contrastsecurity.com/")

BASEURL=CONTRAST_URL + "Contrast/api/ng/%s" % CONTRAST_ORG
VERIFY_CERT = False
LIBPREFIX = 'log4j'
headers = {"Accept": "application/json", "Content-Type": "application/json", "API-Key": CONTRAST_API_KEY, "Authorization": CONTRAST_AUTHORIZATION}

grpdict = {}
appdict = {}
appusersdict = {}

def getLibsForOrg(pName, pIncr):
  offset = 0

  # urllib = (BASEURL) + "/libraries/filter?expand=skip_links,apps,servers,vulns,manifest,status,usage_counts&limit=%s&offset=%s&sort=score" % (str(pIncr), str(offset))
  urllib = BASEURL + "/libraries/filter?expand=skip_links,apps,vulns,usage_counts&limit=%s&offset=%s&sort=score" % (str(pIncr), str(offset))
  jBody = "{\"quickFilter\": \"ALL\", \"q\": \"%s\"}" %pName

  rc = requests.post(urllib, headers=headers, json=json.loads(jBody), verify=VERIFY_CERT)
  if rc.status_code == 400:
    print('*** API call failed. Check authorization credential?')
    sys.exit()
  data = rc.json()

  # paginate through the libraries
  libcnt = data['count']
  liboffset = 0
  while (liboffset < libcnt):

    libs = data['libraries']
    for alib in libs:
      libname = alib['file_name']

      # match for library name with the specified prefix string
      if (libname[0:5] != pName):
        continue
      libversion = alib['version']


      # check for major and sub version numbers - reporting only 2.x
      # (2.14.1 and below)
      sublist = libversion.split('.')

      if (sublist[0] == '1'):
        # print('found 1.x')
        continue
      elif (int(sublist[1]) > 14 and sublist[2] < 2):
        # print('skipping version > 2.14.1' + libversion)
        continue
      # else:
      #   print(libversion)

      libhash = alib['hash']
      liblang = alib['app_language']
      libclassesusedcount = alib['classes_used']
      apps = alib['apps']
      # servers = []
      # if (alib['servers'] != None):
      #   for asvr in alib['servers']:
      #     servers.append(asvr['server_id'])

      for app in apps:
        appid = app['app_id']
        appname = app['name']

        # Keying on appid which means only the 1st instance with the same
        # prefix will be reported. The same also applies with only the first
        # version number encountered to use compound key with appid, lib name,
        # and version if that needs to be expanded

        if (not (appid in appdict)):
          urlapp = (BASEURL) + "/applications/%s?expand=skip_links,license" %appid
          arc = requests.get(urlapp, headers=headers)
          adata = arc.json()
          pappid = ''
          pappname = ''

          if ('parentApplicationId' in adata['application']):
            pappid = adata['application']['parentApplicationId']
            urlapp = (BASEURL) + "/applications/%s?expand=skip_links,license" %pappid
            brc = requests.get(urlapp, headers=headers)
            bdata = brc.json()
            pappname = bdata['application']['name']
          # adict = {appid: [appname, libname, libhash, libversion, liblang, libclassesused, servers]}
          adict = {appid: [appname, pappname, libname, libhash, libversion, liblang, libclassesusedcount]}
          appdict.update(adict)

    liboffset += pIncr
    urllib = (BASEURL) + "/libraries/filter?expand=skip_links,apps&limit=%s&offset=%s" % (pIncr, str(liboffset))
    rc = requests.post(urllib, headers=headers, json=json.loads(jBody))
    data = rc.json()

  return appdict

# def getGroupsForOrg():
#   urlgrp = (BASEURL) + "/groups?expand=applications,skip_links&sort=name"
#   rc = requests.get(urlgrp, headers=headers)
#   data = rc.json()
#   adict = {}
#   for agrp in data['custom_groups']['groups']:
#     if ('applications' in agrp):
#       for app in agrp['applications']:
#         appname = app['application']['name']
#         appid = app['application']['app_id']
#         adict = {agrp['group_id']: [agrp['name'], appid, appname]}
#         grpdict.update(adict)
#   return grpdict

def getUsersForOrg():
  urluser = (BASEURL) + "/users?expand=skip_links&sort=name"
  rc = requests.get(urluser, headers=headers)
  data = rc.json()

  # get the list of authorized apps accessible by the user
  for auser in data['users']:
    urluseraccess = (BASEURL) + "/users/%s/access?expand=applications,skip_links" %auser['user_uid']
    arc = requests.get(urluseraccess, headers=headers)
    adata = arc.json()
    for app in adata['applications']:
      # only picking up Java apps
      if (('language' in app) and (not (app['language'] == 'Java'))):
        continue
      users = appusersdict.get(app['application']['app_id'])
      if (users is not None):
        users.append(auser['user_uid'])
      else:
        users = [auser['user_uid']]
    adict = {app['application']['app_id']: users}
    appusersdict.update(adict)
  return appusersdict.update(adict)

def main():
  # getGroupsForOrg()
  getLibsForOrg(LIBPREFIX, 50)
  getUsersForOrg()

  seperator = ','
  with open('vulnerableApps.csv', 'w') as vf:
    for appid in appdict:
      llist = appdict.get(appid)
      ulist = appusersdict.get(appid)

      # write out {app name, parent app name, library name, version, use count, users}
      appname = llist[0]
      if (llist[1] != ''):
        appname = llist[1]
      if (ulist is not None):
        joinedunames = ','.join(ulist)
        vf.write(appname + seperator + llist[2] + seperator + llist[4] + seperator + str(llist[6]) + seperator + joinedunames + '\n')
      else:
        vf.write(appname + seperator + llist[2] + seperator + llist[4] + seperator + str(llist[6]) + '\n')

if __name__ == '__main__':
    main()
